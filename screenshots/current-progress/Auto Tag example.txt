Your Current Auto-Tag System Overview
Your system is a rule-based transaction tagging engine built in Google Apps Script for Google Sheets. It automatically applies categories and tags to financial transactions based on matching criteria.

Core Functionality
1. Rule Creation & Storage

Users define rules in an "AutoTag" sheet with two parts:

Search Criteria (what to match)
Apply Criteria (what to change)


Rules are stored in a configuration area with columns for status, dates, and all parameters
Each rule can be toggled "Active" or "Inactive"

2. Search/Matching System
Search Criteria Options:

Description (text matching - contains)
Amount (exact, min/max range)
Date (from date, min/max range)
Category (existing category filter)
Tags (must match ALL specified tags)

How Matching Works:
javascript// All criteria must match (AND logic)
- If description specified → must contain text (case-insensitive)
- If amount specified → must match within $0.01
- If amount range → must fall between min/max
- If date filters → must be within date range
- If category → must contain category text
- If tags → transaction must have ALL specified tags
3. Tag Application Logic
Two Modes:
Mode A: Remove Old Tags = "Yes"

Completely replaces existing tags with new tags
"Old, Tags" → "New, Tags"

Mode B: Remove Old Tags = "No" (Smart Merge)

Adds new tags only if they don't already exist
Preserves existing tags
Case-insensitive duplicate detection
"Old, Tags" + "New" → "Old, Tags, New"

4. Dynamic Tag Patterns
Your system supports date-based tag patterns that resolve at runtime:
javascript// Pattern → Resolution
{yy}       → 25
{yyyy}     → 2025  
{dd}       → 30
{mm}       → 09
{mmyy}     → 0925
{ddmmyy}   → 300925
{ddmmyyyy} → 30092025
Example:

Rule tag: "Subscription {yyyy}, Recurring {mmyy}"
Applied as: "Subscription 2025, Recurring 0925"

5. Processing Flow
1. User clicks "Run AutoTag" button
   ↓
2. System loads all active rules
   ↓
3. Fetches all transactions from account sheets
   (Up, BOQ, WestPac, Cash, ANZ Saver, ANZ Mortgage)
   ↓
4. For each rule:
   - Filter transactions by search criteria
   - For each matching transaction:
     → Resolve dynamic tag patterns
     → Apply category (if specified)
     → Apply tags (merge or replace mode)
     → Update sheet cells
     → Queue API sync (if available)
   ↓
5. Update rule "Last Run" timestamps
   ↓
6. Show results summary
6. Duplicate Prevention

Uses Unique ID and UP ID columns to identify transactions
Skips the "Input" sheet entirely to avoid processing duplicates
Only searches individual bank account sheets


Key Features for Web Implementation
A. Rule Preview System

Users can preview matches before saving rules
Shows first 20 matching transactions
Displays: Amount, Date, Type, Description, Category, Tags, Account

B. Batch Processing

Processes multiple transactions per rule efficiently
Updates are batched to minimize API calls
Transaction limit: configurable (currently no hard limit)

C. Integration Points

queueApiSync() - syncs changes back to bank API
refreshTransactionHistory() - updates UI after changes
Webhook triggers for real-time updates

D. Error Handling

Validates rules before saving (must have search criteria + apply criteria)
Auto-generates rule names if not provided
Logs all operations for debugging
Shows user-friendly error messages


Web Implementation Strategy
For your website, here's how to adapt these concepts:
1. Database Schema
sql-- Rules table
rules (
  id, name, status, created_at, last_run,
  search_description, search_amount_min, search_amount_max,
  search_date_from, search_date_to,
  search_category, search_tags,
  apply_category, apply_tags, 
  remove_old_tags (boolean),
  recurring, recurring_end
)

-- Transactions table
transactions (
  id, amount, date, type, description,
  category, tags, account, unique_id, api_id
)
2. API Endpoints
POST   /api/autotag/rules          - Create rule
GET    /api/autotag/rules          - List rules
PUT    /api/autotag/rules/:id      - Update rule
DELETE /api/autotag/rules/:id      - Delete rule
POST   /api/autotag/preview        - Preview matches
POST   /api/autotag/run            - Execute rules
POST   /api/autotag/run/:id        - Run single rule
3. Core Logic (Pseudocode)
javascriptfunction runAutoTagRules(ruleIds = []) {
  const rules = ruleIds.length 
    ? getRulesByIds(ruleIds) 
    : getActiveRules();
  
  let totalUpdates = 0;
  
  for (const rule of rules) {
    const transactions = filterTransactions(
      getAllTransactions(), 
      rule.searchCriteria
    );
    
    for (const transaction of transactions) {
      if (applyRule(transaction, rule)) {
        totalUpdates++;
      }
    }
    
    updateRuleLastRun(rule.id);
  }
  
  return { rulesProcessed: rules.length, totalUpdates };
}

function applyRule(transaction, rule) {
  let updated = false;
  
  // Apply category
  if (rule.applyCategory && transaction.category !== rule.applyCategory) {
    transaction.category = rule.applyCategory;
    updated = true;
  }
  
  // Apply tags with dynamic pattern resolution
  if (rule.applyTags) {
    const resolvedTags = resolveDynamicPatterns(rule.applyTags);
    
    if (rule.removeOldTags) {
      transaction.tags = resolvedTags;
      updated = true;
    } else {
      const newTags = smartMergeTags(transaction.tags, resolvedTags);
      if (newTags !== transaction.tags) {
        transaction.tags = newTags;
        updated = true;
      }
    }
  }
  
  if (updated) {
    saveTransaction(transaction);
    syncToExternalAPI(transaction);
  }
  
  return updated;
}
4. UI Components Needed

Rule Builder: Form with search/apply criteria fields
Preview Panel: Shows matching transactions before saving
Rule List: Table of active/inactive rules with toggle switches
Execution Dashboard: Shows progress and results
Dynamic Tag Helper: Dropdown with pattern options ({yyyy}, {mmyy}, etc.)

Would you like me to create specific code examples for any of these components or elaborate on particular aspects of the implementation?RetryJand please do one for up ban ktransactionsEditI'll search your project knowledge for the Up Bank transaction system.Searched project for “Up Bank API transactions sync webhook bidirectional”2 resultsUPBankandTransactions.gs4 relevant sectionstextUPBankandTransactions.gs4 relevant sectionstextSearched project for “edit trigger category tags update API sync queue”4 resultsMain.gstextUPBankandTransactions.gs2 relevant sectionstextUPBankandTransactions.gs3 relevant sectionstextATagCreator.GS2 relevant sectionstextSearched project for “transfer detection dual entry accounts balance”3 resultsUPBankandTransactions.gs4 relevant sectionstextUPBankandTransactions.gs3 relevant sectionstextATagCreator.GStextPerfect! Now I can give you a comprehensive explanation of your Up Bank transaction system.
Your Up Bank Transaction System - Complete Explanation

System Architecture Overview
Your system is a full bidirectional sync between Google Sheets and Up Bank's API, with real-time updates, transfer detection, and infinite loop prevention.
Core Components:

UpAPI Sheet - Raw API data storage (25 columns)
Account Sheets - User-friendly transaction views (9 columns each)
Input Sheet - Manual entry form + consolidated view
Webhook System - Real-time updates from Up Bank
Edit Trigger System - Sheet → API sync
Transfer Detection - Automatic dual-entry creation


Column Structure (A-I)
A: Amount          - Transaction value (negative = expense, positive = income)
B: Payment Date    - When transaction occurred
C: Trans Type      - Purchase, Transfer, ATM, etc.
D: Description     - Transaction description
E: Category        - Single-select category (dropdown)
F: Tags            - Multi-select tags (comma-separated)
G: Account         - Which account/bank
H: Unique ID       - UUID for duplicate prevention
I: UP ID           - Up Bank's transaction ID (enables API sync)

1. Data Flow Architecture
Flow Diagram:
Up Bank API
    ↓ (webhook/polling)
UpAPI Sheet (raw data)
    ↓ (processing)
Account Sheets (Up, BOQ, WestPac, Cash, ANZ Saver, ANZ Mortgage)
    ↔ (bidirectional sync)
Input Sheet (consolidated view)
    ↑ (user edits)
    ↓ (API sync queue)
Back to Up Bank API

2. Webhook System (Real-Time Updates)
How It Works:
Setup Process:
javascript1. Deploy Google Apps Script as web app
2. Register webhook URL with Up Bank API
3. Store webhook secret for signature verification
4. Listen for events
Event Types Handled:

TRANSACTION_CREATED - New transaction from bank
TRANSACTION_SETTLED - Transaction finalized
TRANSACTION_MODIFIED - Category/tags changed in Up app
TRANSACTION_DELETED - Transaction removed
PING - Health check

Security:
javascript// Signature verification prevents unauthorized requests
function verifyWebhookSignature(e) {
  const receivedSignature = e.headers['X-Up-Authenticity-Signature'];
  const secretKey = getWebhookSecret();
  
  const expectedSignature = HMAC_SHA256(
    e.postData.contents, 
    secretKey
  );
  
  return receivedSignature === expectedSignature;
}
Processing Flow:
1. Webhook receives POST from Up Bank
   ↓
2. Verify signature (security)
   ↓
3. Parse event type
   ↓
4. Fetch full transaction details from API
   ↓
5. Store in UpAPI sheet
   ↓
6. Process to appropriate account sheet
   ↓
7. Check for transfers (create dual entries if needed)
   ↓
8. Return 200 OK to Up Bank

3. Transfer Detection & Dual Entry System
Transfer Detection Logic:
javascriptfunction detectTransfer(transaction) {
  const description = transaction.description.toLowerCase();
  
  // Pattern matching for transfers
  const transferPatterns = {
    'BOQ': /boq|bank of queensland/i,
    'WestPac': /westpac|west pac/i,
    'Cash': /cash|atm withdrawal/i,
    'ANZ Saver': /anz.*saver|saver.*anz/i,
    'ANZ Mortgage': /anz.*mortgage|mortgage.*anz/i
  };
  
  for (const [bankName, pattern] of Object.entries(transferPatterns)) {
    if (pattern.test(description)) {
      return {
        isTransfer: true,
        bankName: bankName,
        direction: transaction.amount >= 0 ? 'CREDIT' : 'DEBIT',
        amount: Math.abs(transaction.amount)
      };
    }
  }
  
  return { isTransfer: false };
}
Dual Entry Creation:
When a transfer is detected between Up and another bank:
Example: $500 transfer from Up to BOQ
Entry 1 (Up account):
Amount: -500
Date: 2025-09-30
Type: Transfer
Description: Transfer to BOQ
Category: Bank Transfer
Account: Up
UP ID: abc-123-xyz  ← Has UP ID
Entry 2 (BOQ account):
Amount: +500
Date: 2025-09-30
Type: Transfer
Description: Transfer from Up
Category: Bank Transfer
Account: BOQ
UP ID: (empty)  ← No UP ID (manual bank entry)
Duplicate Prevention:
javascript// Check for existing transfer within 5-minute window
function isDuplicateTransfer(sheet, newTransfer) {
  const existingData = sheet.getAllTransactions();
  const transDate = new Date(newTransfer.date);
  
  for (const existing of existingData) {
    const timeDiff = Math.abs(existing.date - transDate);
    
    if (
      timeDiff < 300000 &&  // 5 minutes = 300,000ms
      Math.abs(existing.amount - newTransfer.amount) < 0.01 &&
      existing.type === 'Transfer'
    ) {
      return true;  // Duplicate found
    }
  }
  
  return false;
}

4. Bidirectional Sync System
A. Sheet → API Sync (User Edits)
Edit Trigger Flow:
User edits Category or Tags in sheet
    ↓
onEditInstallable() triggered
    ↓
Validate: Does row have UP ID in column I?
    ↓ YES
queueApiSync() called
    ↓
Acquire processing lock (prevent race conditions)
    ↓
Convert user values to API format
    ↓
Make PATCH request to Up Bank API
    ↓
Update UpAPI sheet
    ↓
Release lock
Tag Sync Logic:
Multi-Select Toggle System:
javascript// When user types a tag name:
function handleTagEdit(e) {
  const typedTag = e.value.trim();
  const existingTags = e.oldValue ? e.oldValue.split(',').map(t => t.trim()) : [];
  
  let updatedTags;
  
  if (existingTags.includes(typedTag)) {
    // Tag exists → REMOVE it (toggle off)
    updatedTags = existingTags.filter(t => t !== typedTag);
  } else {
    // Tag doesn't exist → ADD it (toggle on)
    updatedTags = [...existingTags, typedTag];
  }
  
  const newTagString = updatedTags.join(', ');
  e.range.setValue(newTagString);
  
  queueApiSync(sheet, row, 'tags', newTagString);
}
User Experience:

User has: "Groceries, Food"
User types: "Groceries" → Result: "Food" (removed)
User types: "Recurring" → Result: "Groceries, Food, Recurring" (added)

Category Sync (Single Select):
javascriptfunction handleCategoryEdit(e) {
  const newCategory = e.value.trim();
  
  // Simply replace with new category
  queueApiSync(sheet, row, 'category', newCategory);
}
B. API → Sheet Sync (Bank Updates)
Polling System (Backup to Webhooks):
javascript// Runs every 5 minutes via time trigger
function autoSyncTransactions() {
  const lock = acquireProcessingLock();
  if (!lock) return;  // Another sync in progress
  
  try {
    // Fetch latest transactions from Up Bank
    const response = fetchTransactionsSince(lastSyncTime);
    
    for (const transaction of response.data) {
      if (!isTransactionProcessed(transaction.id)) {
        processNewTransaction(transaction);
      } else {
        checkForUpdates(transaction);
      }
    }
    
    updateLastSyncTime();
  } finally {
    lock.releaseLock();
  }
}

5. Infinite Loop Prevention
The Problem:
User edits tag in sheet
    → Triggers API update
        → Up Bank updates transaction
            → Webhook fires
                → Updates sheet
                    → Triggers another edit
                        → INFINITE LOOP! ❌
The Solution:
Lock System:
javascriptfunction queueApiSync(sheet, row, field, value) {
  const lock = LockService.getScriptLock();
  
  try {
    lock.waitLock(10000);  // Wait up to 10 seconds
    
    // Set flag: "This update came from us"
    PropertiesService.getScriptProperties()
      .setProperty(`UPDATING_${upId}`, 'true');
    
    // Make API call
    updateUpBankTransaction(upId, field, value);
    
    // Keep flag for 5 seconds
    Utilities.sleep(5000);
    
  } finally {
    // Remove flag
    PropertiesService.getScriptProperties()
      .deleteProperty(`UPDATING_${upId}`);
    
    lock.releaseLock();
  }
}
Webhook Handler Checks Flag:
javascriptfunction handleTransactionModified(eventData) {
  const transactionId = eventData.transactionId;
  
  // Check if WE initiated this update
  const isOurUpdate = PropertiesService.getScriptProperties()
    .getProperty(`UPDATING_${transactionId}`);
  
  if (isOurUpdate) {
    Logger.log('Ignoring self-initiated update');
    return;  // Skip processing to prevent loop
  }
  
  // This is a genuine external update, process it
  processTransactionUpdate(eventData);
}

6. Duplicate Prevention System
Three-Layer Protection:
Layer 1: UP ID Check
javascript// Every Up Bank transaction has unique ID
if (existingUpIds.includes(newTransaction.upId)) {
  console.log('Duplicate UP ID prevented');
  return false;  // Don't add
}
Layer 2: Unique ID Check
javascript// Manual entries get UUID
if (existingUniqueIds.includes(newTransaction.uniqueId)) {
  console.log('Duplicate Unique ID prevented');
  return false;
}
Layer 3: Fuzzy Matching (for transfers)
javascript// Check amount, date, type together
function isSimilarTransaction(trans1, trans2) {
  const amountMatch = Math.abs(trans1.amount - trans2.amount) < 0.01;
  const dateMatch = Math.abs(trans1.date - trans2.date) < 300000; // 5 min
  const typeMatch = trans1.type === trans2.type;
  
  return amountMatch && dateMatch && typeMatch;
}

7. API Integration Details
Authentication:
javascriptconst headers = {
  'Authorization': `Bearer ${API_TOKEN}`,
  'Content-Type': 'application/json'
};
Key Endpoints:
Fetch Transactions:
GET /transactions?page[size]=100&filter[since]=2025-07-01
Update Category:
PATCH /transactions/{id}/relationships/category
Body: {
  "data": {
    "type": "categories",
    "id": "groceries"
  }
}
Update Tags:
PATCH /transactions/{id}/relationships/tags
Body: {
  "data": [
    { "type": "tags", "id": "recurring" },
    { "type": "tags", "id": "subscription" }
  ]
}
List Categories/Tags (for dropdowns):
GET /categories
GET /tags

8. Error Handling & Retry Logic
javascriptfunction makeApiCall(endpoint, method = 'GET', payload = null, retries = 3) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const response = UrlFetchApp.fetch(BASE_URL + endpoint, {
        method: method,
        headers: headers,
        payload: payload ? JSON.stringify(payload) : null,
        muteHttpExceptions: true
      });
      
      const statusCode = response.getResponseCode();
      
      if (statusCode === 200 || statusCode === 201) {
        return JSON.parse(response.getContentText());
      }
      
      if (statusCode === 429) {  // Rate limit
        Logger.log(`Rate limited, waiting ${attempt * 2} seconds`);
        Utilities.sleep(attempt * 2000);
        continue;
      }
      
      if (statusCode >= 500) {  // Server error
        Logger.log(`Server error (${statusCode}), retrying...`);
        Utilities.sleep(attempt * 1000);
        continue;
      }
      
      throw new Error(`API error: ${statusCode} - ${response.getContentText()}`);
      
    } catch (error) {
      if (attempt === retries) {
        logFailure(endpoint, error);
        throw error;
      }
      Utilities.sleep(1000 * attempt);
    }
  }
}

Web Implementation Strategy
Database Schema:
sql-- Transactions table
CREATE TABLE transactions (
    id UUID PRIMARY KEY,
    up_transaction_id VARCHAR(255) UNIQUE,  -- Links to Up Bank
    amount DECIMAL(10,2),
    date TIMESTAMP,
    type VARCHAR(50),
    description TEXT,
    category VARCHAR(100),
    tags TEXT[],  -- PostgreSQL array
    account VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    source VARCHAR(20),  -- 'up_bank', 'manual', 'transfer'
    processed BOOLEAN DEFAULT false
);

-- Webhook events log
CREATE TABLE webhook_events (
    id SERIAL PRIMARY KEY,
    event_type VARCHAR(50),
    transaction_id UUID,
    payload JSONB,
    processed BOOLEAN DEFAULT false,
    received_at TIMESTAMP DEFAULT NOW()
);

-- Sync queue (for retries)
CREATE TABLE sync_queue (
    id SERIAL PRIMARY KEY,
    transaction_id UUID,
    field VARCHAR(50),
    new_value TEXT,
    attempts INT DEFAULT 0,
    last_attempt TIMESTAMP,
    status VARCHAR(20),  -- 'pending', 'processing', 'completed', 'failed'
    created_at TIMESTAMP DEFAULT NOW()
);
API Endpoints:
javascript// Webhook receiver
POST /api/webhooks/upbank
  - Verify signature
  - Queue event for processing
  - Return 200 immediately

// Transaction endpoints
GET    /api/transactions
POST   /api/transactions          // Manual entry
PATCH  /api/transactions/:id
DELETE /api/transactions/:id

// Sync operations
POST   /api/sync/pull             // Fetch from Up Bank
POST   /api/sync/push/:id         // Push changes to Up Bank
GET    /api/sync/status

// Transfer operations
GET    /api/transfers/detect/:id  // Check if transaction is transfer
POST   /api/transfers/create-dual // Create dual entry
Core Logic (Node.js/Express Example):
javascript// Webhook handler
app.post('/api/webhooks/upbank', async (req, res) => {
  // Verify signature
  const signature = req.headers['x-up-authenticity-signature'];
  if (!verifySignature(req.body, signature)) {
    return res.status(401).send('Unauthorized');
  }
  
  // Queue for async processing
  await redisQueue.add('webhook-event', {
    eventType: req.body.data.attributes.eventType,
    payload: req.body
  });
  
  res.status(200).send('OK');
});

// Queue processor
async function processWebhookEvent(job) {
  const { eventType, payload } = job.data;
  
  // Check if this is our own update (loop prevention)
  const isOwnUpdate = await redis.get(`updating:${transactionId}`);
  if (isOwnUpdate) {
    return;
  }
  
  switch (eventType) {
    case 'TRANSACTION_CREATED':
      await handleNewTransaction(payload);
      break;
    case 'TRANSACTION_MODIFIED':
      await handleUpdatedTransaction(payload);
      break;
  }
}

// Edit handler
app.patch('/api/transactions/:id', async (req, res) => {
  const { category, tags } = req.body;
  const transaction = await db.transactions.findById(req.params.id);
  
  if (!transaction.up_transaction_id) {
    return res.status(400).json({ 
      error: 'Cannot sync: No Up Bank ID' 
    });
  }
  
  // Set loop prevention flag
  await redis.setex(`updating:${transaction.up_transaction_id}`, 10, 'true');
  
  try {
    // Update Up Bank
    await upBankApi.updateTransaction(
      transaction.up_transaction_id,
      { category, tags }
    );
    
    // Update local DB
    await db.transactions.update(req.params.id, {
      category,
      tags,
      updated_at: new Date()
    });
    
    res.json({ success: true });
    
  } catch (error) {
    // Queue for retry
    await db.sync_queue.insert({
      transaction_id: req.params.id,
      field: 'category_tags',
      new_value: JSON.stringify({ category, tags }),
      status: 'pending'
    });
    
    res.status(500).json({ error: 'Sync failed, queued for retry' });
  } finally {
    await redis.del(`updating:${transaction.up_transaction_id}`);
  }
});

// Transfer detection
async function detectAndCreateTransfer(transaction) {
  const transferInfo = detectTransfer(transaction.description);
  
  if (!transferInfo.isTransfer) return;
  
  // Check for existing transfer
  const existing = await db.transactions.findOne({
    account: transferInfo.bankName,
    amount: -transaction.amount,  // Opposite sign
    date: { 
      $gte: new Date(transaction.date.getTime() - 300000),  // -5 min
      $lte: new Date(transaction.date.getTime() + 300000)   // +5 min
    },
    type: 'Transfer'
  });
  
  if (existing) {
    console.log('Transfer already exists');
    return;
  }
  
  // Create dual entry
  await db.transactions.insert({
    id: uuid(),
    amount: -transaction.amount,
    date: transaction.date,
    type: 'Transfer',
    description: `Transfer ${transaction.amount > 0 ? 'from' : 'to'} Up`,
    category: 'Bank Transfer',
    account: transferInfo.bankName,
    source: 'transfer'
  });
}